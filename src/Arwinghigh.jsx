/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 arwinghigh.glb
*/

import React, { useEffect, useRef, useState } from "react";
import { PerspectiveCamera, useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";

export function Model(props) {
  const { nodes, materials } = useGLTF("/arwinghigh.glb");
  const lightRef = useRef();
  const light2Ref = useRef();
  const light3Ref = useRef();
  const light4Ref = useRef();
  const light5Ref = useRef();
  const arwingRef = useRef();
  const [rollRight, setRollRight] = useState(false);
  const [rollLeft, setRollLeft] = useState(false);
  const [rolling, setRolling] = useState(false);
  const [keydown, setKeydown] = useState(false);
  const [lastTap, setLastTap] = useState({ key: "", time: 0 });

  let lastPressed = 0;

  const [ rollLeftTarget, setRollLeftTarget ] = useState(0);
  const [ rollRightTarget, setRollRightTarget ] = useState(0);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key == "e") {
        setKeydown(true);
        // setRollRight(true);
        // setRolling(true);
        const rollRightTargetNow = arwingRef.current.rotation.z + Math.PI * 2;
        setRollRightTarget(rollRightTargetNow);
      }
      if (e.key == "a" && !rolling) {
        setKeydown(true);

        // setRollLeft(true);
        // setRolling(true);
        const rollLeftTargetNow = arwingRef.current.rotation.z - Math.PI * 2;
        setRollLeftTarget(rollLeftTargetNow);
      }
    };

    const handleKeyUp = (e) => {
      if (e.key == "e" && keydown) {
        console.log("keyup")
        setKeydown(false);
        setRollRight(true);
        setRolling(true);
      }
      if (e.key == "a" && keydown) {
        setKeydown(false);
        setRollLeft(true);
        setRolling(true);
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);

    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [keydown, rolling]);

  // if(arwingRef.current){
  // rollRightTarget = arwingRef.current.rotation.z + Math.PI * 2;
  // rollLeftTarget = arwingRef.current.rotation.z - Math.PI * 2;
  // }
  const rotationSpeed = 0.1 * Math.PI;
  useFrame(({ clock }) => {
    const scale = new THREE.Vector3(1, 1, 1).multiplyScalar(
      1 + 0.2 * THREE.MathUtils.clamp(
        Math.abs(Math.sin(clock.getElapsedTime() * 50)),
        0,
        2
      )
    );
    lightRef.current.scale.copy(scale);
    light2Ref.current.scale.copy(scale);
    light3Ref.current.scale.copy(scale);
    light4Ref.current.scale.copy(scale);
    light5Ref.current.scale.copy(scale);

    if (rollRight) {
      
      if (arwingRef.current.rotation.z <= rollRightTarget) {
        arwingRef.current.rotation.z += rotationSpeed;
      }
      if (arwingRef.current.rotation.z > rollRightTarget) {
        arwingRef.current.rotation.z = rollRightTarget;
        setRollRight(false);
        setRolling(false);
      }
    }

    if (rollLeft) {
      if (arwingRef.current.rotation.z >= rollLeftTarget) {
        arwingRef.current.rotation.z -= rotationSpeed;
      }
      if (arwingRef.current.rotation.z < rollLeftTarget) {
        arwingRef.current.rotation.z = rollLeftTarget;
        setRollLeft(false);
        setRolling(false);
      }
    }
  });
  return (
    <group
      {...props}
      dispose={null}
      rotation={[0, 0, Math.PI]}
      ref={arwingRef}
      scale={[0.2, 0.2, 0.2]}
    >
      <mesh
        castShadow={true}
        geometry={nodes.Plane.geometry}
        material={materials.Material_1}
        rotation={[Math.PI / 2, 0, 0]}
      />
      <mesh
        castShadow={true}
        geometry={nodes.Plane001_Plane004.geometry}
        material={materials.Material_1}
        rotation={[Math.PI / 2, 0, 0]}
      />

      <mesh position={[0,0,-2]} ref={lightRef}>
        <sphereGeometry args={[0.5, 32, 32]} />
        <meshStandardMaterial emissive="#ffd228" emissiveIntensity={20} toneMapped={false} />
      </mesh> 
     <pointLight color="#ffd228" position={[0,0,-5]} intensity={2} distance={10}/>

      <mesh position={[0,0,-2.5]} ref={light2Ref}>
        <sphereGeometry args={[0.4, 8, 8]} />
        <meshStandardMaterial emissive="#ffd228" emissiveIntensity={15} toneMapped={false} />
      </mesh>
      <mesh position={[0,0,-2.8]} ref={light3Ref}>
        <sphereGeometry args={[0.3, 8, 8]} />
        <meshStandardMaterial emissive="#ffd228" emissiveIntensity={10} toneMapped={false} />
      </mesh>
      <mesh position={[0,0,-3.1]} ref={light4Ref}>
        <sphereGeometry args={[0.2, 8, 8]} />
        <meshStandardMaterial emissive="#ffd228" emissiveIntensity={5} toneMapped={false} />
      </mesh>
      <mesh position={[0,0,-3.2]} ref={light5Ref}>
        <sphereGeometry args={[0.1, 8, 8]} />
        <meshStandardMaterial emissive="#ffd228" emissiveIntensity={2} toneMapped={false} />
      </mesh>
    </group>
  );
}

useGLTF.preload("/arwinghigh.glb");
